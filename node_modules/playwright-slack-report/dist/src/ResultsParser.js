"use strict";
/* eslint-disable no-shadow */
/* eslint-disable no-underscore-dangle */
/* eslint-disable import/extensions */
/* eslint-disable no-control-regex */
/* eslint-disable class-methods-use-this */
/* eslint-disable no-param-reassign */
Object.defineProperty(exports, "__esModule", { value: true });
class ResultsParser {
    result;
    constructor() {
        this.result = [];
    }
    async getParsedResults(allTests) {
        const failures = await this.getFailures();
        // use Playwright recommended way of extracting test stats:
        // https://github.com/microsoft/playwright/issues/27498#issuecomment-1766766335
        const stats = {
            expected: 0, skipped: 0, unexpected: 0, flaky: 0,
        };
        // eslint-disable-next-line no-plusplus
        for (const test of allTests)
            ++stats[test.outcome()];
        const summary = {
            passed: stats.expected,
            failed: stats.unexpected,
            flaky: stats.flaky,
            skipped: stats.skipped,
            failures,
            tests: [],
        };
        for (const suite of this.result) {
            summary.tests = summary.tests.concat(suite.testSuite.tests);
        }
        return summary;
    }
    async getFailures() {
        const failures = [];
        for (const suite of this.result) {
            for (const test of suite.testSuite.tests) {
                if (test.status === 'failed' || test.status === 'timedOut') {
                    // only flag as failed if the last attempt has failed
                    if (test.retries === test.retry) {
                        failures.push({
                            test: ResultsParser.getTestName(test),
                            failureReason: test.reason,
                        });
                    }
                }
            }
        }
        return failures;
    }
    static getTestName(failedTest) {
        const testName = failedTest.name;
        if (failedTest.browser && failedTest.projectName) {
            if (failedTest.browser === failedTest.projectName) {
                return `${testName} [${failedTest.browser}]`;
            }
            return `${testName} [Project Name: ${failedTest.projectName}] using ${failedTest.browser}`;
        }
        return testName;
    }
    updateResults(data) {
        if (data.testSuite.tests.length > 0) {
            this.result.push(data);
        }
    }
    addTestResult(suiteName, testCase, projectBrowserMapping) {
        const testResults = [];
        const projectSettings = this.determineBrowser(testCase._projectId, projectBrowserMapping);
        for (const result of testCase.results) {
            testResults.push({
                suiteName,
                name: testCase.title,
                status: result.status,
                browser: projectSettings.browser,
                projectName: projectSettings.projectName,
                retry: result.retry,
                retries: testCase.retries,
                startedAt: new Date(result.startTime).toISOString(),
                endedAt: new Date(new Date(result.startTime).getTime() + result.duration).toISOString(),
                reason: this.safelyDetermineFailure(result),
                attachments: result.attachments,
            });
        }
        this.updateResults({
            testSuite: {
                title: suiteName,
                tests: testResults,
            },
        });
    }
    safelyDetermineFailure(result) {
        if (result.errors.length > 0) {
            const fullError = result.errors
                .map((e) => `${e.message}\r\n${e.stack ? e.stack : ''}\r\n`)
                .join();
            return this.cleanseReason(fullError);
        }
        return `${this.cleanseReason(result.error?.message)} \n ${this.cleanseReason(result.error?.stack)}`;
    }
    cleanseReason(rawReaseon) {
        // eslint-disable-next-line prefer-regex-literals
        const ansiRegex = new RegExp('([\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~])))', 'g');
        const ansiCleansed = rawReaseon ? rawReaseon.replace(ansiRegex, '') : '';
        const logsStripped = ansiCleansed
            .replace(/============================================================\n/g, '')
            .replace(/============================================================\r\n/g, '')
            .replace(/=========================== logs ===========================\n/g, '');
        return logsStripped;
    }
    determineBrowser(projectName, browserMappings) {
        const browserMapping = browserMappings.find((mapping) => mapping.projectName === projectName);
        if (browserMapping) {
            return {
                projectName: browserMapping.projectName,
                browser: browserMapping.browser,
            };
        }
        return {
            projectName: '',
            browser: '',
        };
    }
}
exports.default = ResultsParser;
